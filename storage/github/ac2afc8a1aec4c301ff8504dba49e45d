C:28:"Guzzle\Http\Message\Response":9412:{{"status":200,"body":"[{\"url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/comments\/161727222\",\"html_url\":\"https:\/\/github.com\/angular\/angular\/issues\/5570#issuecomment-161727222\",\"issue_url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/5570\",\"id\":161727222,\"user\":{\"login\":\"juliemr\",\"id\":2081709,\"avatar_url\":\"https:\/\/avatars.githubusercontent.com\/u\/2081709?v=3\",\"gravatar_id\":\"\",\"url\":\"https:\/\/api.github.com\/users\/juliemr\",\"html_url\":\"https:\/\/github.com\/juliemr\",\"followers_url\":\"https:\/\/api.github.com\/users\/juliemr\/followers\",\"following_url\":\"https:\/\/api.github.com\/users\/juliemr\/following{\/other_user}\",\"gists_url\":\"https:\/\/api.github.com\/users\/juliemr\/gists{\/gist_id}\",\"starred_url\":\"https:\/\/api.github.com\/users\/juliemr\/starred{\/owner}{\/repo}\",\"subscriptions_url\":\"https:\/\/api.github.com\/users\/juliemr\/subscriptions\",\"organizations_url\":\"https:\/\/api.github.com\/users\/juliemr\/orgs\",\"repos_url\":\"https:\/\/api.github.com\/users\/juliemr\/repos\",\"events_url\":\"https:\/\/api.github.com\/users\/juliemr\/events{\/privacy}\",\"received_events_url\":\"https:\/\/api.github.com\/users\/juliemr\/received_events\",\"type\":\"User\",\"site_admin\":false},\"created_at\":\"2015-12-03T17:41:44Z\",\"updated_at\":\"2015-12-03T17:41:44Z\",\"body\":\"You could just write this as:\\r\\n\\r\\n```js\\r\\ndescribe('RaceService', () => {\\r\\n  beforeEachProviders(() => [RaceService]);\\r\\n\\r\\n  it('should return a promise of 2 races', inject([RaceService],(service) => {\\r\\n    return service.list().then(races => {\\r\\n      expect(races.length).toBe(2);\\r\\n    });\\r\\n  }));\\r\\n});\\r\\n```\\r\\n\\r\\nBut I see your larger point. I imagine that it would be more mental overhead to have to sometimes use `inject` but other times remember to use `runWithAsyncErrorCatching` (or a better name). Do you have a suggestion of what it should look like?\"},{\"url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/comments\/161916799\",\"html_url\":\"https:\/\/github.com\/angular\/angular\/issues\/5570#issuecomment-161916799\",\"issue_url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/5570\",\"id\":161916799,\"user\":{\"login\":\"cexbrayat\",\"id\":411874,\"avatar_url\":\"https:\/\/avatars.githubusercontent.com\/u\/411874?v=3\",\"gravatar_id\":\"\",\"url\":\"https:\/\/api.github.com\/users\/cexbrayat\",\"html_url\":\"https:\/\/github.com\/cexbrayat\",\"followers_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/followers\",\"following_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/following{\/other_user}\",\"gists_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/gists{\/gist_id}\",\"starred_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/starred{\/owner}{\/repo}\",\"subscriptions_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/subscriptions\",\"organizations_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/orgs\",\"repos_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/repos\",\"events_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/events{\/privacy}\",\"received_events_url\":\"https:\/\/api.github.com\/users\/cexbrayat\/received_events\",\"type\":\"User\",\"site_admin\":false},\"created_at\":\"2015-12-04T09:18:25Z\",\"updated_at\":\"2015-12-04T09:18:25Z\",\"body\":\"I did not add a suggestion because I was not really sure what would be the best :)\\r\\nI wouldn't mind having 2 functions each dedicated to their purpose: one for injection, one for running an async test.\\r\\n\\r\\nFor a sync test, we would have:\\r\\n\\r\\n```javascript\\r\\ndescribe('RaceService', () => {\\r\\n  let service;\\r\\n  beforeEachProviders(() => [RaceService]);\\r\\n  beforeEach(inject([RaceService], raceService => service = raceService));\\r\\n\\r\\n  \/\/ sync test and service already injected, no need to wrap with async or inject\\r\\n  it('should return a promise of 2 races', () => {\\r\\n    let races = service.list();\\r\\n    expect(races.length).toBe(2);\\r\\n  });\\r\\n});\\r\\n```\\r\\n\\r\\n```javascript\\r\\ndescribe('RaceService', () => {\\r\\n  let service;\\r\\n  beforeEachProviders(() => [RaceService]);\\r\\n\\r\\n  \/\/ sync test and service needed, we wrap with inject\\r\\n  it('should return a promise of 2 races', inject([RaceService], (service) => {\\r\\n    let races = service.list();\\r\\n    expect(races.length).toBe(2);\\r\\n  }));\\r\\n});\\r\\n```\\r\\n\\r\\nFor async tests, maybe we should have an `async` function like:\\r\\n\\r\\n```javascript\\r\\ndescribe('RaceService', () => {\\r\\n  let service;\\r\\n  beforeEachProviders(() => [RaceService]);\\r\\n  beforeEach(inject([RaceService], raceService => service = raceService));\\r\\n\\r\\n  \/\/ async test and service already injected, no need to wrap with inject\\r\\n  it('should return a promise of 2 races', async(() => {\\r\\n    service.list().then(races => {\\r\\n      expect(races.length).toBe(2);\\r\\n    });\\r\\n  }));\\r\\n});\\r\\n```\\r\\n\\r\\n```javascript\\r\\ndescribe('RaceService', () => {\\r\\n  let service;\\r\\n  beforeEachProviders(() => [RaceService]);\\r\\n\\r\\n  \/\/ async test and service not already injected, need to wrap with inject and async\\r\\n  it('should return a promise of 2 races', async(inject([RaceService], (service) => {\\r\\n    service.list().then(races => {\\r\\n      expect(races.length).toBe(2);\\r\\n    });\\r\\n  })));\\r\\n});\\r\\n```\\r\\n\"},{\"url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/comments\/188516327\",\"html_url\":\"https:\/\/github.com\/angular\/angular\/issues\/5570#issuecomment-188516327\",\"issue_url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/5570\",\"id\":188516327,\"user\":{\"login\":\"juliemr\",\"id\":2081709,\"avatar_url\":\"https:\/\/avatars.githubusercontent.com\/u\/2081709?v=3\",\"gravatar_id\":\"\",\"url\":\"https:\/\/api.github.com\/users\/juliemr\",\"html_url\":\"https:\/\/github.com\/juliemr\",\"followers_url\":\"https:\/\/api.github.com\/users\/juliemr\/followers\",\"following_url\":\"https:\/\/api.github.com\/users\/juliemr\/following{\/other_user}\",\"gists_url\":\"https:\/\/api.github.com\/users\/juliemr\/gists{\/gist_id}\",\"starred_url\":\"https:\/\/api.github.com\/users\/juliemr\/starred{\/owner}{\/repo}\",\"subscriptions_url\":\"https:\/\/api.github.com\/users\/juliemr\/subscriptions\",\"organizations_url\":\"https:\/\/api.github.com\/users\/juliemr\/orgs\",\"repos_url\":\"https:\/\/api.github.com\/users\/juliemr\/repos\",\"events_url\":\"https:\/\/api.github.com\/users\/juliemr\/events{\/privacy}\",\"received_events_url\":\"https:\/\/api.github.com\/users\/juliemr\/received_events\",\"type\":\"User\",\"site_admin\":false},\"created_at\":\"2016-02-24T23:36:40Z\",\"updated_at\":\"2016-02-24T23:36:40Z\",\"body\":\"cc @vikerman \"},{\"url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/comments\/189852510\",\"html_url\":\"https:\/\/github.com\/angular\/angular\/issues\/5570#issuecomment-189852510\",\"issue_url\":\"https:\/\/api.github.com\/repos\/angular\/angular\/issues\/5570\",\"id\":189852510,\"user\":{\"login\":\"gsans\",\"id\":4660316,\"avatar_url\":\"https:\/\/avatars.githubusercontent.com\/u\/4660316?v=3\",\"gravatar_id\":\"\",\"url\":\"https:\/\/api.github.com\/users\/gsans\",\"html_url\":\"https:\/\/github.com\/gsans\",\"followers_url\":\"https:\/\/api.github.com\/users\/gsans\/followers\",\"following_url\":\"https:\/\/api.github.com\/users\/gsans\/following{\/other_user}\",\"gists_url\":\"https:\/\/api.github.com\/users\/gsans\/gists{\/gist_id}\",\"starred_url\":\"https:\/\/api.github.com\/users\/gsans\/starred{\/owner}{\/repo}\",\"subscriptions_url\":\"https:\/\/api.github.com\/users\/gsans\/subscriptions\",\"organizations_url\":\"https:\/\/api.github.com\/users\/gsans\/orgs\",\"repos_url\":\"https:\/\/api.github.com\/users\/gsans\/repos\",\"events_url\":\"https:\/\/api.github.com\/users\/gsans\/events{\/privacy}\",\"received_events_url\":\"https:\/\/api.github.com\/users\/gsans\/received_events\",\"type\":\"User\",\"site_admin\":false},\"created_at\":\"2016-02-28T11:57:06Z\",\"updated_at\":\"2016-02-28T11:57:06Z\",\"body\":\"Having Jasmine's asynchronous handling already with done this seems unnecessary unless I'm missing something.\"}]","headers":{"Server":["GitHub.com"],"Date":["Tue, 08 Mar 2016 07:31:33 GMT"],"Content-Type":["application\/json; charset=utf-8"],"Content-Length":["7485"],"Status":["200 OK"],"X-RateLimit-Limit":["5000"],"X-RateLimit-Remaining":["4901"],"X-RateLimit-Reset":["1457423538"],"Cache-Control":["private, max-age=60, s-maxage=60"],"Vary":["Accept, Authorization, Cookie, X-GitHub-OTP","Accept-Encoding"],"ETag":["\"90a423e940a1ce56e24ca299f9b7c544\""],"X-GitHub-Media-Type":["github.v3; format=json"],"Access-Control-Expose-Headers":["ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval"],"Access-Control-Allow-Origin":["*"],"Content-Security-Policy":["default-src 'none'"],"Strict-Transport-Security":["max-age=31536000; includeSubdomains; preload"],"X-Content-Type-Options":["nosniff"],"X-Frame-Options":["deny"],"X-XSS-Protection":["1; mode=block"],"X-Served-By":["318e55760cf7cdb40e61175a4d36cd32"],"X-GitHub-Request-Id":["C5E8F8E0:10E9D:3A3E84B:56DE7FD5"]}}}